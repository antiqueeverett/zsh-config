#!/bin/zsh
# git aliases Everett M - 20/July/2020
# optimized for submodule workflow

function is_submodule() {
  (cd "$(git rev-parse --show-toplevel)/.." &&
    git rev-parse --is-inside-work-tree) | grep -q true
}

# -- removing a submodule
function ggsub_remove() {
  git submodule deinit -f -- "$1"
  rm -rf .git/modules/"$1"
  git rm -f "$1"
}

# -- pulling submodules
function ggsub_pull() {
  if [[ $(git submodule foreach 'git status') ]]; then # if submodules exist
    git submodule update --remote
    git pull --recurse-submodules
  else
    git pull
  fi
}

# -- ignoring submodules
function ggsub_ignore() {
  eval "git config submodule.$1.ignore all"
}

# -- showing all submodules
function ggsub_list() {
  git config --file .gitmodules --get-regexp path | awk '{ print $2 }'
}

# -- checking the most recent change
function gg_diff() {
  if git diff-index --quiet HEAD --; then # if after commit
    git diff HEAD^ HEAD
  else
    if git diff --cached --exit-code; then # if after state
      git diff
    else
      git diff --cached # if after change
    fi
  fi
}

# -- checking for submodules
function has_submodules() {
  if [[ $(git submodule foreach 'git status') ]]; then
    true
  else
    false
  fi
}

# -- checking each submodules state
function report_submodule_state() {
  root="$1"
  for dir in $(find "$root" -maxdepth 2 -mindepth 1 -type d); do
    cd "$dir" || return
    if [[ -f .git ]]; then
      if [[ $(git diff --stat) != '' ]]; then
        echo
        printf '%s\n' "${PWD##*/}"           # report repo name
        git diff --quiet || echo ' -- dirty' # report dirty state
      else
        echo
        printf '%s\n' "${PWD##*/}"
        [[ -n $(git status -s) ]] || echo ' -- clean' # report clean state
      fi
    fi
  done
}

# -- safely pushing a repo with submodules
function ggsub_push() {
  curr_wd="$PWD"
  if has_submodules; then
    report_submodule_state "$PWD"
    echo -n "\n -- Continue push?  [Y/N]"
    read -r REPLY
    if [[ $REPLY =~ ^[Yy]$ ]]; then
      cd "$curr_wd" || return
      git push origin master
    fi
  else
    cd "$curr_wd" || return
    git push origin master
  fi
  cd "$curr_wd" || return
}

# -- checking status all repositories
function report() {
  curr_wd="$PWD"
  report_submodule_state "$HOME/Repositories/"
  cd "$curr_wd" || return
}

function gg_commit() {
  eval "git commit -m \"$*\""
}

# -- removing files
function gg_remove_file() {
  git rm --cached "$1"
  rm -rf "$1"
}

# -- patch adding
function gg_add_patch() {
  git add --patch "$1"
}

# -- add submodule
alias ggsubadd='git submodule add'

# -- remove submodule
alias ggsubrm='ggsub_remove'

# -- pull submodules
alias ggpull='ggsub_pull'

# -- push submodules
alias ggpush='ggsub_push'

# --list submodules
alias ggsublist='ggsub_list'

# -- ignore submodule
alias ggsubignore='ggsub_ignore'

# -- global status report on all repos
alias ggstatus=report

# -- remove file
alias ggrmfile='gg_remove_file'

# -- clone
alias ggclone='git clone'

# -- check out
alias ggco='git checkout'

# -- mv file
alias ggmv='git mv'

# -- check repo size
alias ggsize='git count-objects -vH'

# -- check repo status
alias ggs='git status'

# -- stage all changes
alias gga='git add .'

# -- select what to stage
alias ggpatch='gg_add_patch'

# -- commit
alias ggc='gg_commit'

# -- rebase
alias ggrebase='git rebase -i'

# -- list tracked
alias gglisttracked='git ls-tree -r master --name-only'

# -- reset hard
alias ggrhard='git reset --hard'

# -- reset soft
alias ggrsoft='git reset --soft'

# -- show latest change
alias ggdiff='gg_diff'

# -- use diff tool
alias ggdifftool='git difftool'

# -- viewing logs
alias ggl='git log'
alias ggrl='git reflog'
alias ggverify='git log --pretty="format:%h %G? %aN  %s"'
